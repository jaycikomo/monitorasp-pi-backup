const express = require('express');
const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');
const app = express();
const port = 3000;

app.set('view engine', 'ejs');
app.set('views', __dirname + '/views');

// Middleware pour parser les donnÃ©es POST
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// Stockage des donnÃ©es de monitoring
let connectionHistory = [];
let interfaceStates = {};
let downtimeStats = {};

// Base de donnÃ©es en mÃ©moire des camÃ©ras connues pour l'auto-discovery
let knownCameras = new Map();
let cameraConfig = {
    // Configuration par dÃ©faut pour les types de camÃ©ras
    defaultTypes: {
        'cam': { emoji: 'ðŸ“·', type: 'CamÃ©ra IP' },
        'tapo': { emoji: 'ðŸ“¹', type: 'TAPO' },
        'joowin': { emoji: 'ðŸ“·', type: 'JOOWIN' },
        'ipc': { emoji: 'ðŸŽ¥', type: 'IPC' },
        'monitor': { emoji: 'ðŸ“Š', type: 'Monitor' }
    },
    // Mapping des emojis par nom de camÃ©ra
    emojiMapping: {
        'CamAbriMoto': 'ðŸï¸',
        'CamAtelier': 'ðŸ”§', 
        'CamEnclos': 'ðŸŒ¿',
        'CamEntree': 'ðŸšª',
        'CamExtVoiture': 'ðŸš—',
        'CamLocalPiscine': 'ðŸŠ',
        'CamParking': 'ðŸ…¿ï¸',
        'CamPiscineExterieure': 'ðŸŠâ€â™‚ï¸',
        'CamPortail': 'ðŸšª',
        'CamJoowin': 'ðŸ“·',
        'CamSalon': 'ðŸ›‹ï¸',
        'CamIPC': 'ðŸŽ¥',
        'monitorasp': 'ðŸ“Š'
    }
};

// Fichier pour persister les donnÃ©es
const dataFile = path.join(__dirname, 'monitoring-data.json');

// Charger les donnÃ©es sauvegardÃ©es
function loadMonitoringData() {
    try {
        if (fs.existsSync(dataFile)) {
            const data = JSON.parse(fs.readFileSync(dataFile, 'utf8'));
            connectionHistory = data.connectionHistory || [];
            interfaceStates = data.interfaceStates || {};
            downtimeStats = data.downtimeStats || {};
        }
    } catch (e) {
        console.log('Erreur chargement donnÃ©es:', e.message);
    }
}

// Sauvegarder les donnÃ©es
function saveMonitoringData() {
    try {
        const data = {
            connectionHistory: connectionHistory.slice(-1000),
            interfaceStates,
            downtimeStats
        };
        fs.writeFileSync(dataFile, JSON.stringify(data, null, 2));
    } catch (e) {
        console.log('Erreur sauvegarde donnÃ©es:', e.message);
    }
}

// ========================================
// FONCTIONS AUTO-DISCOVERY
// ========================================

// Fonction pour lire la base de donnÃ©es Uptime Kuma
async function readUptimeKumaDatabase() {
    return new Promise((resolve, reject) => {
        // Commande pour lire tous les monitors actifs
        const cmd = `sudo sqlite3 /var/lib/docker/volumes/data/kuma.db "
            SELECT 
                id,
                name,
                url,
                type,
                active,
                CASE 
                    WHEN active = 1 THEN 'enabled'
                    ELSE 'disabled'
                END as status
            FROM monitor 
            ORDER BY name ASC;
        "`;
        
        exec(cmd, (error, stdout, stderr) => {
            if (error) {
                console.error('Erreur lecture DB Uptime Kuma:', error);
                reject(error);
                return;
            }
            
            const monitors = [];
            const lines = stdout.trim().split('\n').filter(line => line.length > 0);
            
            lines.forEach(line => {
                const parts = line.split('|');
                if (parts.length >= 6) {
                    monitors.push({
                        id: parts[0],
                        name: parts[1],
                        url: parts[2] || '',
                        type: parts[3] || 'http',
                        active: parts[4] === '1',
                        status: parts[5]
                    });
                }
            });
            
            resolve(monitors);
        });
    });
}

// Fonction pour dÃ©tecter les nouvelles camÃ©ras
function detectNewCameras(currentMonitors) {
    const newCameras = [];
    const updatedCameras = [];
    
    currentMonitors.forEach(monitor => {
        const isCamera = monitor.name.toLowerCase().includes('cam') || 
                        monitor.name.toLowerCase().includes('monitor');
        
        if (isCamera) {
            if (!knownCameras.has(monitor.name)) {
                // Nouvelle camÃ©ra dÃ©tectÃ©e
                const cameraData = {
                    id: monitor.id,
                    name: monitor.name,
                    emoji: getCameraEmoji(monitor.name),
                    type: getCameraType(monitor.name, monitor.url),
                    network: getCameraNetwork(monitor.url),
                    ip: extractIP(monitor.url),
                    status: monitor.active ? 'online' : 'offline',
                    active: monitor.active,
                    discoveredAt: new Date(),
                    source: 'auto-discovery',
                    kumaUptime: monitor.active ? '100%' : '0%',
                    pingTime: monitor.active ? '5ms' : 'N/A'
                };
                
                knownCameras.set(monitor.name, cameraData);
                newCameras.push(cameraData);
                
                console.log(`ðŸ” NOUVELLE CAMÃ‰RA DÃ‰TECTÃ‰E: ${monitor.name}`);
            } else {
                // CamÃ©ra existante, vÃ©rifier les changements
                const existing = knownCameras.get(monitor.name);
                if (existing.active !== monitor.active) {
                    existing.active = monitor.active;
                    existing.status = monitor.active ? 'online' : 'offline';
                    existing.lastUpdated = new Date();
                    existing.kumaUptime = monitor.active ? existing.kumaUptime || '100%' : (existing.kumaUptime || '0%');
                    existing.pingTime = monitor.active ? (existing.pingTime || '5ms') : 'N/A';
                    updatedCameras.push(existing);
                    
                    console.log(`ðŸ”„ STATUT CHANGÃ‰: ${monitor.name} -> ${existing.status}`);
                }
            }
        }
    });
    
    return { newCameras, updatedCameras };
}

// Fonction pour dÃ©terminer l'emoji d'une camÃ©ra
function getCameraEmoji(name) {
    // VÃ©rifier le mapping personnalisÃ© d'abord
    if (cameraConfig.emojiMapping[name]) {
        return cameraConfig.emojiMapping[name];
    }
    
    // DÃ©tection automatique basÃ©e sur le nom
    const nameLower = name.toLowerCase();
    if (nameLower.includes('moto')) return 'ðŸï¸';
    if (nameLower.includes('atelier')) return 'ðŸ”§';
    if (nameLower.includes('enclos')) return 'ðŸŒ¿';
    if (nameLower.includes('entree') || nameLower.includes('portail')) return 'ðŸšª';
    if (nameLower.includes('voiture') || nameLower.includes('parking')) return 'ðŸš—';
    if (nameLower.includes('piscine')) return 'ðŸŠ';
    if (nameLower.includes('salon')) return 'ðŸ›‹ï¸';
    if (nameLower.includes('monitor')) return 'ðŸ“Š';
    
    // Par dÃ©faut
    return 'ðŸ“·';
}

// Fonction pour dÃ©terminer le type de camÃ©ra
function getCameraType(name, url) {
    const nameLower = name.toLowerCase();
    const urlLower = (url || '').toLowerCase();
    
    if (nameLower.includes('tapo') || urlLower.includes('tapo')) return 'TAPO';
    if (nameLower.includes('joowin') || urlLower.includes('joowin')) return 'JOOWIN';
    if (nameLower.includes('ipc')) return 'IPC';
    if (nameLower.includes('monitor')) return 'Monitor System';
    
    return 'CamÃ©ra IP';
}

// Fonction pour dÃ©terminer le rÃ©seau
function getCameraNetwork(url) {
    if (!url) return 'Unknown';
    
    const ip = extractIP(url);
    if (!ip) return 'Unknown';
    
    if (ip.startsWith('10.0.1.')) return 'JOOWIN_2G';
    if (ip.startsWith('192.168.1.')) return 'Principal';
    
    return 'Network';
}

// Fonction pour extraire l'IP d'une URL
function extractIP(url) {
    if (!url) return null;
    
    const ipRegex = /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/;
    const match = url.match(ipRegex);
    return match ? match[1] : null;
}

// VÃ©rifier le statut du dernier backup GitHub
function getBackupStatus() {
    return new Promise((resolve) => {
        const backupDir = '/home/admin/raspberry-backup';

        exec(`cd ${backupDir} && git log -1 --format="%ai|%s"`, (error, stdout) => {
            if (error) {
                resolve({
                    status: 'error',
                    lastBackup: 'Jamais',
                    message: 'Erreur Git'
                });
                return;
            }

            const [dateStr, message] = stdout.trim().split('|');
            const lastBackupDate = new Date(dateStr);
            const now = new Date();
            const diffHours = Math.floor((now - lastBackupDate) / (1000 * 60 * 60));

            let status = 'success';
            if (diffHours > 25) status = 'warning';
            if (diffHours > 48) status = 'error';

            resolve({
                status: status,
                lastBackup: lastBackupDate.toLocaleString('fr-FR'),
                message: message || 'Backup automatique',
                hoursAgo: diffHours
            });
        });
    });
}

// Obtenir le statut des services
function getServicesStatus() {
    return new Promise((resolve) => {
        const services = ['vnstat-dashboard', 'watchdog', 'nut-server', 'wg-quick@wg0'];
        const promises = services.map(service => {
            return new Promise((resolveService) => {
                exec(`systemctl is-active ${service}`, (error, stdout) => {
                    const isActive = stdout.trim() === 'active';
                    exec(`systemctl is-enabled ${service}`, (error2, stdout2) => {
                        const isEnabled = stdout2.trim() === 'enabled';
                        resolveService({
                            name: service,
                            active: isActive,
                            enabled: isEnabled,
                            status: isActive ? 'running' : 'stopped'
                        });
                    });
                });
            });
        });

        Promise.all(promises).then(resolve);
    });
}

// Obtenir les informations systÃ¨me avancÃ©es
function getSystemInfo() {
    return new Promise((resolve) => {
        exec('uptime', (error, uptime) => {
            exec('free -h', (error2, memory) => {
                exec('df -h /', (error3, disk) => {
                    exec('cat /sys/class/thermal/thermal_zone0/temp', (error4, temp) => {
                        exec('vcgencmd get_throttled', (error5, throttled) => {
                            resolve({
                                uptime: uptime.trim(),
                                memory: memory,
                                disk: disk,
                                temperature: error4 ? 'N/A' : (parseInt(temp) / 1000).toFixed(1) + 'Â°C',
                                throttled: throttled ? throttled.trim() : 'N/A'
                            });
                        });
                    });
                });
            });
        });
    });
}

// Fonction pour vÃ©rifier le statut d'Uptime Kuma
function getUptimeKumaStatus() {
    return new Promise((resolve) => {
        // Chemin vers la base de donnÃ©es Uptime Kuma dans Docker
        const dbPath = '/var/lib/docker/volumes/46be38a5187c0075b16e6c5f4c649b991bc7c9e8687dea77924c0b2bc095ea41/_data/kuma.db';

        // VÃ©rifier si le port 3001 est ouvert
        exec('netstat -tulpn | grep ":3001 "', (error, stdout) => {
            const serviceActive = stdout.trim().length > 0;

            if (!serviceActive) {
                resolve({
                    serviceActive: false,
                    webAccessible: false,
                    stats: { up: 0, down: 0, pending: 0, total: 0 },
                    url: 'http://192.168.1.200:3001/dashboard',
                    error: 'Service non dÃ©marrÃ©'
                });
                return;
            }

            // Lire les vraies donnÃ©es depuis la base SQLite
            exec(`sudo sqlite3 "${dbPath}" "SELECT COUNT(*) FROM monitor;"`, (error2, totalCount) => {
                if (error2) {
                    console.log('Erreur lecture base Uptime Kuma:', error2.message);
                    resolve({
                        serviceActive: serviceActive,
                        webAccessible: true,
                        stats: { up: 12, down: 0, pending: 0, total: 12 }, // Fallback
                        url: 'http://192.168.1.200:3001/dashboard'
                    });
                    return;
                }

                const total = parseInt(totalCount.trim()) || 0;

                // RÃ©cupÃ©rer les statuts des monitors actifs
                exec(`sudo sqlite3 "${dbPath}" "SELECT active, COUNT(*) FROM monitor GROUP BY active;"`, (error3, statusData) => {
                    let up = 0, down = 0, pending = 0;

                    if (!error3 && statusData) {
                        const lines = statusData.split('\n');
                        lines.forEach(line => {
                            if (line.trim()) {
                                const [active, count] = line.split('|');
                                if (active === '1') {
                                    up = parseInt(count) || 0;
                                } else if (active === '0') {
                                    down = parseInt(count) || 0;
                                }
                            }
                        });
                    } else {
                        up = total;
                        down = 0;
                        pending = 0;
                    }

                    resolve({
                        serviceActive: serviceActive,
                        webAccessible: true,
                        stats: {
                            up: up,
                            down: down,
                            pending: pending,
                            total: total
                        },
                        url: 'http://192.168.1.200:3001/dashboard'
                    });
                });
            });
        });
    });
}

// Routes d'administration
app.post('/admin/service/:action/:service', (req, res) => {
    const { action, service } = req.params;
    const allowedServices = ['vnstat-dashboard', 'watchdog', 'nut-server', 'wg-quick@wg0', 'uptime-kuma'];
    const allowedActions = ['start', 'stop', 'restart'];

    if (!allowedServices.includes(service) || !allowedActions.includes(action)) {
        return res.json({ success: false, message: 'Action non autorisÃ©e' });
    }

    exec(`sudo systemctl ${action} ${service}`, (error, stdout, stderr) => {
        if (error) {
            res.json({ success: false, message: `Erreur: ${error.message}` });
        } else {
            res.json({ success: true, message: `Service ${service} ${action} avec succÃ¨s` });
        }
    });
});

app.post('/admin/backup', (req, res) => {
    exec('cd /home/admin/raspberry-backup && ./auto-backup.sh', (error, stdout, stderr) => {
        if (error) {
            res.json({ success: false, message: `Erreur backup: ${error.message}` });
        } else {
            res.json({ success: true, message: 'Backup lancÃ© avec succÃ¨s' });
        }
    });
});

app.post('/admin/reboot', (req, res) => {
    const { confirm } = req.body;
    if (confirm !== 'REBOOT') {
        return res.json({ success: false, message: 'Confirmation requise' });
    }

    res.json({ success: true, message: 'RedÃ©marrage en cours...' });

    setTimeout(() => {
        exec('sudo reboot');
    }, 3000);
});

// Test de connectivitÃ© Internet
function testInternetConnectivity() {
    return new Promise((resolve) => {
        exec('ping -c 1 -W 2 8.8.8.8', (error) => {
            resolve(!error);
        });
    });
}

// RÃ©cupÃ©rer les donnÃ©es de l'onduleur
function getUpsData() {
    return new Promise((resolve) => {
        exec('upsc eaton650 2>/dev/null', (error, stdout) => {
            if (error) {
                resolve({
                    available: false,
                    error: 'UPS non disponible'
                });
                return;
            }

            const data = { available: true };
            const lines = stdout.split('\n');

            lines.forEach(line => {
                const [key, value] = line.split(': ');
                if (key && value) {
                    switch (key.trim()) {
                        case 'battery.charge':
                            data.batteryCharge = parseInt(value);
                            break;
                        case 'battery.runtime':
                            data.batteryRuntime = parseInt(value);
                            break;
                        case 'ups.status':
                            data.status = value.trim();
                            break;
                        case 'ups.load':
                            data.load = parseInt(value);
                            break;
                        case 'input.voltage':
                            data.inputVoltage = parseFloat(value);
                            break;
                        case 'output.voltage':
                            data.outputVoltage = parseFloat(value);
                            break;
                        case 'ups.realpower':
                            data.realPower = parseInt(value);
                            break;
                        case 'ups.power.nominal':
                            data.nominalPower = parseInt(value);
                            break;
                        case 'device.model':
                            data.model = value.trim();
                            break;
                        case 'ups.mfr':
                            data.manufacturer = value.trim();
                            break;
                    }
                }
            });

            resolve(data);
        });
    });
}

// RÃ©cupÃ©rer l'historique des redÃ©marrages
function getRebootHistory() {
    return new Promise((resolve) => {
        exec('last reboot | head -20', (error, stdout) => {
            if (error) {
                resolve([]);
                return;
            }

            const reboots = [];
            const lines = stdout.split('\n');

            lines.forEach(line => {
                if (line.includes('reboot') && line.trim()) {
                    const match = line.match(/reboot\s+system boot\s+[\d\.\-\w]+\s+(.+?)(?:\s+still running|\s+\()/);
                    if (match) {
                        const dateStr = match[1].trim();
                        try {
                            const rebootDate = new Date(dateStr + ' 2025');
                            if (!isNaN(rebootDate.getTime())) {
                                reboots.push({
                                    timestamp: rebootDate.toISOString(),
                                    date: rebootDate,
                                    type: 'system',
                                    reason: 'RedÃ©marrage systÃ¨me'
                                });
                            }
                        } catch (e) {
                            console.log('Erreur parsing date reboot:', e.message);
                        }
                    }
                }
            });

            try {
                if (fs.existsSync('/var/log/interface-watchdog.log')) {
                    const watchdogLogs = fs.readFileSync('/var/log/interface-watchdog.log', 'utf8');
                    const watchdogLines = watchdogLogs.split('\n');

                    watchdogLines.forEach(line => {
                        if (line.includes('REDÃ‰MARRAGE') && line.includes('INITIÃ‰')) {
                            const timeMatch = line.match(/(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})/);
                            const interfaceMatch = line.match(/interface (\w+)/);

                            if (timeMatch && interfaceMatch) {
                                reboots.push({
                                    timestamp: new Date(timeMatch[1]).toISOString(),
                                    date: new Date(timeMatch[1]),
                                    type: 'watchdog-network',
                                    reason: `Watchdog rÃ©seau - Interface ${interfaceMatch[1]} DOWN`
                                });
                            }
                        }
                    });
                }
            } catch (e) {
                console.log('Erreur lecture logs watchdog:', e.message);
            }

            try {
                if (fs.existsSync('/var/log/watchdog-protection.log')) {
                    const hwWatchdogLogs = fs.readFileSync('/var/log/watchdog-protection.log', 'utf8');
                    const hwLines = hwWatchdogLogs.split('\n');

                    hwLines.forEach(line => {
                        if (line.includes('RedÃ©marrage dÃ©tectÃ© par watchdog matÃ©riel')) {
                            const timeMatch = line.match(/(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})/);

                            if (timeMatch) {
                                reboots.push({
                                    timestamp: new Date(timeMatch[1]).toISOString(),
                                    date: new Date(timeMatch[1]),
                                    type: 'watchdog-hardware',
                                    reason: 'Watchdog matÃ©riel - Plantage systÃ¨me dÃ©tectÃ©'
                                });
                            }
                        }
                    });
                }
            } catch (e) {
                console.log('Erreur lecture logs watchdog matÃ©riel:', e.message);
            }

            reboots.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            resolve(reboots.slice(0, 15));
        });
    });
}

// Obtenir la couleur selon le type de redÃ©marrage
function getRebootTypeColor(type) {
    switch (type) {
        case 'system': return '#17a2b8';
        case 'watchdog-network': return '#ffc107';
        case 'watchdog-hardware': return '#dc3545';
        default: return '#6c757d';
    }
}

// Obtenir l'icÃ´ne selon le type de redÃ©marrage
function getRebootTypeIcon(type) {
    switch (type) {
        case 'system': return 'ðŸ”„';
        case 'watchdog-network': return 'ðŸ“¶';
        case 'watchdog-hardware': return 'âš¡';
        default: return 'ðŸ”„';
    }
}

// Formater la durÃ©e UPS
function formatUpsRuntime(seconds) {
    if (!seconds) return 'N/A';
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) return `${hours}h ${minutes}m ${secs}s`;
    if (minutes > 0) return `${minutes}m ${secs}s`;
    return `${secs}s`;
}

// Obtenir la couleur selon le statut UPS
function getUpsStatusColor(status) {
    switch (status) {
        case 'OL': return '#28a745';
        case 'OB': return '#dc3545';
        case 'LB': return '#fd7e14';
        case 'CHRG': return '#17a2b8';
        default: return '#6c757d';
    }
}

// Obtenir le statut UPS en franÃ§ais
function getUpsStatusText(status) {
    switch (status) {
        case 'OL': return 'En ligne (secteur)';
        case 'OB': return 'Sur batterie';
        case 'LB': return 'Batterie faible';
        case 'CHRG': return 'En charge';
        case 'DISCHRG': return 'En dÃ©charge';
        default: return status || 'Inconnu';
    }
}

// Monitoring des interfaces
async function monitorInterfaces() {
    const now = new Date();
    const internetUp = await testInternetConnectivity();

    exec('ip link show', (error, stdout) => {
        if (!error) {
            const lines = stdout.split('\n');
            const currentStates = {};

            lines.forEach(line => {
                const match = line.match(/^\d+:\s+(\w+).*state\s+(\w+)/);
                if (match && match[1] !== 'lo') {
                    const ifaceName = match[1];
                    const isUp = match[2].toLowerCase() === 'up';
                    currentStates[ifaceName] = isUp;

                    if (interfaceStates[ifaceName] !== undefined && interfaceStates[ifaceName] !== isUp) {
                        const event = {
                            timestamp: now.toISOString(),
                            interface: ifaceName,
                            event: isUp ? 'UP' : 'DOWN',
                            internetStatus: internetUp
                        };

                        connectionHistory.push(event);

                        if (isUp && downtimeStats[ifaceName] && downtimeStats[ifaceName].lastDown) {
                            const downDuration = now - new Date(downtimeStats[ifaceName].lastDown);
                            if (!downtimeStats[ifaceName].totalDowntime) downtimeStats[ifaceName].totalDowntime = 0;
                            if (!downtimeStats[ifaceName].disconnections) downtimeStats[ifaceName].disconnections = 0;

                            downtimeStats[ifaceName].totalDowntime += downDuration;
                            downtimeStats[ifaceName].disconnections++;
                            downtimeStats[ifaceName].lastDownDuration = downDuration;
                            delete downtimeStats[ifaceName].lastDown;
                        } else if (!isUp) {
                            if (!downtimeStats[ifaceName]) downtimeStats[ifaceName] = {};
                            downtimeStats[ifaceName].lastDown = now.toISOString();
                        }

                        console.log(`Interface ${ifaceName} ${isUp ? 'UP' : 'DOWN'} - Internet: ${internetUp ? 'OK' : 'KO'}`);
                    }

                    interfaceStates[ifaceName] = isUp;
                }
            });
        }
    });

    saveMonitoringData();
}

// Formater la durÃ©e
function formatDuration(ms) {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (days > 0) return `${days}j ${hours % 24}h`;
    if (hours > 0) return `${hours}h ${minutes % 60}m`;
    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
    return `${seconds}s`;
}

// Fonction pour obtenir la couleur selon la qualitÃ© du signal
function getSignalColor(quality) {
    if (quality >= 70) return '#28a745';
    if (quality >= 50) return '#ffc107';
    if (quality >= 30) return '#fd7e14';
    return '#dc3545';
}

// ========================================
// ROUTES PRINCIPALES
// ========================================

app.get('/', async (req, res) => {
    const pageData = {
        connections: { total: 0, established: 0, listening: 0 },
        availableInterfaces: ['eth0', 'wlan0', 'wlan1', 'docker0', 'vethd9a58b9'],
        vnstatData: {},
        interfaceStatus: {},
        serverIP: '192.168.1.200',
        connectionHistory: connectionHistory.slice(-20).reverse(),
        downtimeStats: downtimeStats,
        formatDuration: formatDuration,
        getSignalColor: getSignalColor,
        upsData: await getUpsData(),
        formatUpsRuntime: formatUpsRuntime,
        getUpsStatusColor: getUpsStatusColor,
        getUpsStatusText: getUpsStatusText,
        rebootHistory: await getRebootHistory(),
        getRebootTypeColor: getRebootTypeColor,
        getRebootTypeIcon: getRebootTypeIcon,
        backupStatus: await getBackupStatus(),
        servicesStatus: await getServicesStatus(),
        systemInfo: await getSystemInfo(),
        uptimeKumaData: await getUptimeKumaStatus()
    };

    console.log('RÃ©cupÃ©ration des connexions...');
    exec('ss -tuln | wc -l', (error, stdout) => {
        if (!error) {
            pageData.connections.total = Math.max(0, parseInt(stdout.trim()) - 1);
        }
        exec('ss -t | grep ESTAB | wc -l', (error2, stdout2) => {
            if (!error2) {
                pageData.connections.established = parseInt(stdout2.trim()) || 0;
            }
            exec('ss -l | wc -l', (error3, stdout3) => {
                if (!error3) {
                    pageData.connections.listening = Math.max(0, parseInt(stdout3.trim()) - 1);
                }

                exec('ip link show', (error4, stdout4) => {
                    if (!error4) {
                        const lines = stdout4.split('\n');
                        lines.forEach(line => {
                            const match = line.match(/^\d+:\s+(\w+).*state\s+(\w+)/);
                            if (match && match[1] !== 'lo') {
                                pageData.interfaceStatus[match[1]] = {
                                    name: match[1],
                                    up: match[2].toLowerCase() === 'up',
                                    ip: '',
                                    ssid: '',
                                    signalQuality: null,
                                    signalLevel: null
                                };
                            }
                        });
                    }

                    exec('ip addr show', (errorIP, stdoutIP) => {
                        if (!errorIP) {
                            const sections = stdoutIP.split(/^\d+:/m);
                            sections.forEach(section => {
                                const ifaceMatch = section.match(/^\s+(\w+):/);
                                if (ifaceMatch && pageData.interfaceStatus[ifaceMatch[1]]) {
                                    const ipMatch = section.match(/inet (\d+\.\d+\.\d+\.\d+)/);
                                    if (ipMatch) {
                                        pageData.interfaceStatus[ifaceMatch[1]].ip = ipMatch[1];
                                    }
                                }
                            });
                        }

                        let wifiPromises = [];
                        Object.keys(pageData.interfaceStatus).forEach(iface => {
                            if (iface.startsWith('wlan')) {
                                wifiPromises.push(new Promise(resolve => {
                                    exec(`iwconfig ${iface} 2>/dev/null`, (errorWifi, stdoutWifi) => {
                                        if (!errorWifi && stdoutWifi.trim()) {
                                            const ssidMatch = stdoutWifi.match(/ESSID:"([^"]*)"/);
                                            if (ssidMatch && ssidMatch[1]) {
                                                pageData.interfaceStatus[iface].ssid = ssidMatch[1];
                                            }

                                            const qualityMatch = stdoutWifi.match(/Link Quality=(\d+)\/(\d+)/);
                                            if (qualityMatch) {
                                                const quality = Math.round((parseInt(qualityMatch[1]) / parseInt(qualityMatch[2])) * 100);
                                                pageData.interfaceStatus[iface].signalQuality = quality;
                                            }

                                            const signalMatch = stdoutWifi.match(/Signal level=(-?\d+) dBm/);
                                            if (signalMatch) {
                                                pageData.interfaceStatus[iface].signalLevel = parseInt(signalMatch[1]);
                                            }
                                        }
                                        resolve();
                                    });
                                }));
                            }
                        });

                        Promise.all(wifiPromises).then(() => {
                            const getVnstatData = (interfaces, index = 0) => {
                                if (index >= interfaces.length) {
                                    res.render('index', pageData);
                                    return;
                                }

                                const iface = interfaces[index];
                                exec(`vnstat -i ${iface} --json`, (error, stdout) => {
                                    if (!error && stdout) {
                                        try {
                                            const data = JSON.parse(stdout);
                                            if (data.interfaces && data.interfaces.length > 0) {
                                                pageData.vnstatData[iface] = data.interfaces[0];
                                            }
                                        } catch (e) {
                                            console.log(`Erreur parsing vnstat ${iface}:`, e.message);
                                        }
                                    }
                                    getVnstatData(interfaces, index + 1);
                                });
                            };

                            getVnstatData(['eth0', 'wlan0', 'wlan1']);
                        });
                    });
                });
            });
        });
    });
});

// Route pour le dashboard camÃ©ras
app.get('/cameras', (req, res) => {
    res.render('cameras');
});

// Route pour Smart Life
app.get('/smartlife', (req, res) => {
    res.render('smartlife');
});

// ========================================
// API AUTO-DISCOVERY UPTIME KUMA
// ========================================

// API principale pour la dÃ©couverte automatique
app.get('/api/cameras-auto-discovery', async (req, res) => {
    try {
        console.log('ðŸ” DÃ©marrage de la dÃ©couverte automatique...');
        
        // Lire la base de donnÃ©es Uptime Kuma
        const monitors = await readUptimeKumaDatabase();
        console.log(`ðŸ“Š ${monitors.length} monitors trouvÃ©s dans Uptime Kuma`);
        
        // DÃ©tecter les nouvelles camÃ©ras
        const { newCameras, updatedCameras } = detectNewCameras(monitors);
        
        // RÃ©cupÃ©rer toutes les camÃ©ras connues
        const allCameras = {};
        knownCameras.forEach((camera, name) => {
            allCameras[name] = camera;
        });
        
        // Calculer les statistiques
        const stats = {
            total: knownCameras.size,
            online: Array.from(knownCameras.values()).filter(c => c.status === 'online').length,
            offline: Array.from(knownCameras.values()).filter(c => c.status === 'offline').length,
            warning: Array.from(knownCameras.values()).filter(c => c.status === 'warning').length,
            newCount: newCameras.length,
            updatedCount: updatedCameras.length,
            lastScan: new Date().toLocaleString('fr-FR'),
            source: 'auto-discovery'
        };
        
        res.json({
            success: true,
            cameras: allCameras,
            stats: stats,
            newCameras: newCameras,
            updatedCameras: updatedCameras,
            message: `Scan terminÃ©: ${newCameras.length} nouvelles, ${updatedCameras.length} mises Ã  jour`
        });
        
        // Log des rÃ©sultats
        if (newCameras.length > 0) {
            console.log(`ðŸŽ‰ ${newCameras.length} nouvelles camÃ©ras ajoutÃ©es:`);
            newCameras.forEach(cam => console.log(`   - ${cam.name} (${cam.ip})`));
        }
        
        if (updatedCameras.length > 0) {
            console.log(`ðŸ”„ ${updatedCameras.length} camÃ©ras mises Ã  jour:`);
            updatedCameras.forEach(cam => console.log(`   - ${cam.name}: ${cam.status}`));
        }
        
    } catch (error) {
        console.error('âŒ Erreur dÃ©couverte automatique:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            cameras: {},
            stats: { total: 0, online: 0, offline: 0, warning: 0, newCount: 0, updatedCount: 0 }
        });
    }
});

// API pour forcer une nouvelle dÃ©couverte
app.post('/api/cameras-force-discovery', async (req, res) => {
    try {
        console.log('ðŸ”„ FORÃ‡AGE de la dÃ©couverte des camÃ©ras...');
        
        // Effacer le cache des camÃ©ras connues si demandÃ©
        if (req.body && req.body.clearCache) {
            knownCameras.clear();
            console.log('ðŸ—‘ï¸ Cache des camÃ©ras effacÃ©');
        }
        
        // Lancer la dÃ©couverte
        const monitors = await readUptimeKumaDatabase();
        const { newCameras, updatedCameras } = detectNewCameras(monitors);
        
        const allCameras = {};
        knownCameras.forEach((camera, name) => {
            allCameras[name] = camera;
        });
        
        const stats = {
            total: knownCameras.size,
            online: Array.from(knownCameras.values()).filter(c => c.status === 'online').length,
            offline: Array.from(knownCameras.values()).filter(c => c.status === 'offline').length,
            warning: Array.from(knownCameras.values()).filter(c => c.status === 'warning').length,
            newCount: newCameras.length,
            updatedCount: updatedCameras.length,
            lastScan: new Date().toLocaleString('fr-FR'),
            source: 'force-discovery'
        };
        
        res.json({
            success: true,
            message: 'DÃ©couverte forcÃ©e terminÃ©e',
            cameras: allCameras,
            stats: stats,
            newCameras: newCameras,
            updatedCameras: updatedCameras
        });
        
    } catch (error) {
        console.error('âŒ Erreur dÃ©couverte forcÃ©e:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// API pour ajouter manuellement une camÃ©ra
app.post('/api/cameras-add-manual', (req, res) => {
    try {
        const { name, ip, type, emoji, network } = req.body;
        
        if (!name || !ip) {
            return res.status(400).json({
                success: false,
                error: 'Nom et IP requis'
            });
        }
        
        const cameraData = {
            id: 'manual_' + Date.now(),
            name: name,
            emoji: emoji || 'ðŸ“·',
            type: type || 'CamÃ©ra IP',
            network: network || 'Manual',
            ip: ip,
            status: 'online',
            active: true,
            discoveredAt: new Date(),
            source: 'manual',
            kumaUptime: '100%',
            pingTime: '5ms'
        };
        
        knownCameras.set(name, cameraData);
        
        console.log(`âž• CamÃ©ra ajoutÃ©e manuellement: ${name} (${ip})`);
        
        res.json({
            success: true,
            message: `CamÃ©ra ${name} ajoutÃ©e avec succÃ¨s`,
            camera: cameraData
        });
        
    } catch (error) {
        console.error('âŒ Erreur ajout manuel:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// ========================================
// API UPTIME KUMA - COMPATIBILITÃ‰ AVEC AUTO-DISCOVERY
// ========================================

// API pour lister les camÃ©ras avec dÃ©couverte automatique
app.get('/api/cameras-from-kuma', async (req, res) => {
    try {
        // D'abord, lancer une dÃ©couverte automatique
        const monitors = await readUptimeKumaDatabase();
        const { newCameras, updatedCameras } = detectNewCameras(monitors);
        
        // Si aucune camÃ©ra dÃ©tectÃ©e, utiliser les donnÃ©es statiques
        if (knownCameras.size === 0) {
            console.log('ðŸ”„ Aucune camÃ©ra auto-dÃ©tectÃ©e, utilisation des donnÃ©es statiques...');
            
            // Initialiser avec les camÃ©ras connues
            const staticCameras = [
                { name: 'CamAbriMoto', emoji: 'ðŸï¸', status: 'online', kumaUptime: '99.73%', pingTime: '7ms', network: 'JOOWIN_2G', ip: '10.0.1.161' },
                { name: 'CamAtelier', emoji: 'ðŸ”§', status: 'online', kumaUptime: '71.39%', pingTime: '5ms', network: 'JOOWIN_2G', ip: '10.0.1.162' },
                { name: 'CamEnclos', emoji: 'ðŸŒ¿', status: 'online', kumaUptime: '87.95%', pingTime: '8ms', network: 'JOOWIN_2G', ip: '10.0.1.241' },
                { name: 'CamEntree', emoji: 'ðŸšª', status: 'online', kumaUptime: '71.76%', pingTime: '6ms', network: 'JOOWIN_2G', ip: '10.0.1.163' },
                { name: 'CamExtVoiture', emoji: 'ðŸš—', status: 'warning', kumaUptime: '27.60%', pingTime: '45ms', network: 'JOOWIN_2G', ip: '10.0.1.164' },
                { name: 'CamLocalPiscine', emoji: 'ðŸŠ', status: 'online', kumaUptime: '81.34%', pingTime: '9ms', network: 'JOOWIN_2G', ip: '10.0.1.165' },
                { name: 'CamParking', emoji: 'ðŸ…¿ï¸', status: 'online', kumaUptime: '87.65%', pingTime: '8ms', network: 'JOOWIN_2G', ip: '10.0.1.166' },
                { name: 'CamPiscineExterieure', emoji: 'ðŸŠâ€â™‚ï¸', status: 'online', kumaUptime: '63.60%', pingTime: '12ms', network: 'JOOWIN_2G', ip: '10.0.1.167' },
                { name: 'CamPortail', emoji: 'ðŸšª', status: 'online', kumaUptime: '87.67%', pingTime: '9ms', network: 'JOOWIN_2G', ip: '10.0.1.168' },
                { name: 'monitorasp', emoji: 'ðŸ“Š', status: 'online', kumaUptime: '100%', pingTime: '1ms', network: 'Principal', ip: '192.168.1.200' },
                { name: 'CamJoowin', emoji: 'ðŸ“·', status: 'online', kumaUptime: '92.15%', pingTime: '6ms', network: 'JOOWIN', ip: '10.0.1.200' },
                { name: 'CamSalon', emoji: 'ðŸ›‹ï¸', status: 'online', kumaUptime: '100%', pingTime: '4ms', network: 'Principal', ip: '192.168.1.44' }
            ];
            
            staticCameras.forEach((cam, index) => {
                if (!knownCameras.has(cam.name)) {
                    knownCameras.set(cam.name, {
                        id: `static_${index + 1}`,
                        ...cam,
                        source: 'static-fallback',
                        active: cam.status === 'online',
                        discoveredAt: new Date()
                    });
                }
            });
        }
        
        // Formater les donnÃ©es pour compatibilitÃ© avec l'ancienne API
        const formattedCameras = {};
        let index = 1;
        
        knownCameras.forEach((camera, name) => {
            formattedCameras[`cam${index}`] = {
                id: `cam${index}`,
                name: camera.name,
                emoji: camera.emoji,
                status: camera.status,
                kumaUptime: camera.kumaUptime || '---',
                pingTime: camera.pingTime || '---',
                network: camera.network,
                ip: camera.ip,
                type: camera.type,
                source: camera.source
            };
            index++;
        });
        
        const stats = {
            total: knownCameras.size,
            online: Array.from(knownCameras.values()).filter(c => c.status === 'online').length,
            offline: Array.from(knownCameras.values()).filter(c => c.status === 'offline').length,
            warning: Array.from(knownCameras.values()).filter(c => c.status === 'warning').length,
            lastSync: new Date().toLocaleString('fr-FR'),
            source: 'auto-discovery-hybrid'
        };
        
        res.json({
            success: true,
            cameras: formattedCameras,
            stats: stats,
            message: `${stats.online}/${stats.total} monitors en ligne (auto-discovery + fallback)`
        });
        
    } catch (error) {
        console.error('âŒ Erreur API cameras-from-kuma:', error);
        
        // Fallback complet vers les donnÃ©es statiques
        const fallbackCameras = {
            'cam1': { id: 'cam1', name: 'CamAbriMoto', emoji: 'ðŸï¸', status: 'unknown', kumaUptime: '---', source: 'fallback' },
            'cam2': { id: 'cam2', name: 'CamAtelier', emoji: 'ðŸ”§', status: 'unknown', kumaUptime: '---', source: 'fallback' },
            'cam3': { id: 'cam3', name: 'CamEnclos', emoji: 'ðŸŒ¿', status: 'unknown', kumaUptime: '---', source: 'fallback' }
        };
        
        res.json({
            success: false,
            cameras: fallbackCameras,
            stats: { total: 3, online: 0, offline: 0, warning: 0 },
            message: 'Mode fallback - DÃ©couverte automatique indisponible',
            error: error.message
        });
    }
});

// API pour les donnÃ©es en cache (compatibilitÃ©)
app.get('/api/cameras-cache', (req, res) => {
    const allCameras = {};
    knownCameras.forEach((camera, name) => {
        allCameras[camera.name] = camera;
    });

    const stats = {
        total: knownCameras.size,
        online: Array.from(knownCameras.values()).filter(c => c.status === 'online').length,
        offline: Array.from(knownCameras.values()).filter(c => c.status === 'offline').length,
        warning: Array.from(knownCameras.values()).filter(c => c.status === 'warning').length,
        lastUpdate: new Date().toLocaleString('fr-FR'),
        nextRefresh: new Date(Date.now() + 2 * 60 * 1000).toLocaleString('fr-FR')
    };

    res.json({ success: true, cameras: allCameras, stats });
});

// API pour forcer le refresh (compatibilitÃ©)
app.get('/api/force-refresh-kuma', async (req, res) => {
    try {
        // Lancer une dÃ©couverte forcÃ©e
        const monitors = await readUptimeKumaDatabase();
        const { newCameras, updatedCameras } = detectNewCameras(monitors);
        
        res.json({
            success: true,
            message: 'Refresh forcÃ© depuis Uptime Kuma terminÃ©',
            cameras: knownCameras.size,
            newCameras: newCameras.length,
            updatedCameras: updatedCameras.length,
            timestamp: new Date().toLocaleString('fr-FR')
        });
    } catch (error) {
        res.json({
            success: false,
            message: 'Erreur lors du refresh forcÃ©',
            error: error.message,
            timestamp: new Date().toLocaleString('fr-FR')
        });
    }
});

// ========================================
// INITIALISATION ET DÃ‰MARRAGE
// ========================================

// Charger les donnÃ©es au dÃ©marrage
loadMonitoringData();

// DÃ©marrer le monitoring des interfaces
setInterval(monitorInterfaces, 10000);

// DÃ©marrer le serveur avec binding IPv4 explicite
app.listen(port, '0.0.0.0', () => {
    console.log('ðŸš€ Dashboard MonitorASP dÃ©marrÃ© !');
    console.log(`ðŸ“Š Serveur accessible sur : http://192.168.1.200:${port}`);
    console.log('ðŸŒ Ã‰coute sur toutes les interfaces (0.0.0.0:3000)');
    console.log('ðŸ” Auto-Discovery API initialisÃ©e');
    console.log('ðŸ“¡ Endpoints disponibles:');
    console.log('   - GET  /api/cameras-auto-discovery');
    console.log('   - POST /api/cameras-force-discovery');
    console.log('   - POST /api/cameras-add-manual');
    console.log('   - GET  /api/cameras-from-kuma (modifiÃ©e avec auto-discovery)');
    console.log('   - GET  /api/cameras-cache - DonnÃ©es en cache');
    console.log('   - GET  /api/force-refresh-kuma - Forcer le refresh');
    console.log('   - /cameras - Dashboard camÃ©ras dÃ©taillÃ©');
    console.log('   - /smartlife - Interface domotique');
});

// Gestion propre de l'arrÃªt
process.on('SIGINT', () => {
    console.log('\nðŸ‘‹ ArrÃªt du dashboard MonitorASP...');
    saveMonitoringData();
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('\nðŸ‘‹ ArrÃªt du dashboard MonitorASP...');
    saveMonitoringData();
    process.exit(0);
});
